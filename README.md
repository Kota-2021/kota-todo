# kota-todo
# リアルタイム通知・タスク管理 Web API
## 1.概要
大規模アクセス時でも低遅延なレスポンスとリアルタイム性を両立させた、Go言語製のタスク管理Web APIです。
本プロジェクトでは、単なるCRUD機能の実装に留まらず、以下の2点を中核に据えて開発しました。
- 非同期処理による高可用性
Amazon SQSを活用し、重い処理（通知生成等）をメインAPIから切り離すことで、ユーザーへの応答速度を最大化する「疎結合設計」を実現しています 。
- リアルタイム通知基盤
Goの並行処理（Goroutine/Channel）とRedis（Pub/Sub）を組み合わせ、複数ユーザー間での情報更新を即座に共有するWebSocketハブを実装しています
- 防御を前提としたセキュリティ設計
IAMの最小権限原則の適用や、SSMポートフォワーディングによるセキュアなDB接続など、クラウドネイティブな防御策を講じています。
## 2.想定ユースケース
- 中〜大規模組織のタスク管理基盤
課題解決: 多数のユーザーが同時にタスクを更新・閲覧する環境において、Goの並行処理ハブが情報の即時同期を実現し、コミュニケーションの遅延を防ぎます。 
- 高頻度な通知を伴うチーム開発 
課題解決: タスクの期限切れやステータス変更などの通知処理をAmazon SQSへ切り出すことで、ユーザー操作へのレスポンスをミリ秒単位で維持しつつ、背後で確実に通知を配信します。 
- 拡張性を重視したマイクロサービスの一部 
課題解決: インターフェースを用いたDI（依存性注入）設計により、将来的な外部ツール連携やAIによる自動タスク分析機能などの追加が容易な構造となっています。 
- セキュアなリモートワーク環境 
課題解決: JWTによるステートレスな認証と、SSMを用いたセキュアな運用設計により、場所を選ばず安全にアクセスできる基盤を提供します。
## 3.技術スタック
### 言語・フレームワーク
- Go (Gin): Goルーチンの並行処理能力を最大限に活かし、低リソースで高パフォーマンスなWebSocket配信ハブを実現しました。
- JWT (JSON Web Token): ステートレスなユーザー認証を採用 。ECSのオートスケーリング環境下でも、サーバーを跨いでログイン状態を維持できるスケーラブルな設計としています。
### AWSインフラ
- ECS Fargate: マネージドなコンテナ実行環境により、運用コストを抑えつつ、需要に応じた柔軟なスケーリング（水平スケーリング）を可能にしています。
- ALB (Application Load Balancer): WebSocket（L7層）の適切な負荷分散と、ヘルスチェックによる異常検知を制御します。
- SSM ポートフォワーディング: 踏み台サーバーを排除し、プライベートサブネット内のDB/Redisへ安全に接続する実務的なセキュア運用を実現しました。
- S3 / Secrets Manager: TerraformのStateファイル一元管理 、および機密情報を環境変数として動的に注入するセキュアな管理を徹底しています。
### AWSデータ・メッセージング
- RDS (PostgreSQL): データ整合性を担保し、マネージドサービスによる自動バックアップと保守性を確保しています 。
- ElastiCache (Redis): WebSocketのセッション管理（Pub/Sub）および、DDoS対策・流量制御の高速化に活用しています 。
- Amazon SQS: 通知処理を非同期化し、メイン処理の応答速度を向上 。DLQ（デッドレターキュー）とredrive_policyを定義し、障害時の二次調査が可能な堅牢な設計を施しています 。
### 運用・CI/CD
- GitHub Actions: go test による自動テスト、ECRへのイメージプッシュ、ECSデプロイまでを完全自動化 。
- Terraform: VPCからSQSに至る全リソースをコード化し、環境の再現性を100%に保っています 。
- CloudWatch: ECSログの一元管理と、非同期Workerプロセスの生存監視による可観測性を確保しました 。
## 4.アーキテクチャ・設計方針
本プロジェクトでは、長期的な運用とチーム開発を想定し、以下の5つの設計方針を軸に構築しました。
1. クリーンな3層アーキテクチャと依存性逆転 (DIP)
- レイヤーの分離: Handler（外部インターフェース）、Service（ビジネスロジック）、Repository（データ操作）の3層に分離。特定のライブラリ（GinやGORM等）に依存しない構造にすることで、技術スタックの入れ替えや変更に強い設計にしました。
- 依存性の注入 (DI): インターフェースを介して依存関係を管理。これにより、上位レイヤーが下位レイヤーの具体的な実装を意識せず、ユニットテスト時にモックへの差し替えを容易にしています。
2. 疎結合な非同期メッセージング
- タスクの分離: メインのAPI処理から、重い処理（通知処理や期限チェック等）を分離。
- Amazon SQSの活用: APIがSQSにメッセージを投げ、Workerがそれを拾う「プロデューサー・コンシューマー・パターン」を採用。これにより、APIのレスポンスタイムを最小化し、一時的な高負荷時でもシステム全体がダウンしない耐障害性を確保しました。
3. セキュリティ：最小権限の原則と厳格な認可
- 認可ガードの徹底: JWTによる認証だけでなく、全てのAPIエンドポイントにおいて「操作対象のリソースが実行ユーザーのものであるか」を検証する認可ロジックをサービス層に組み込んでいます。
- IAMによる権限の局所化: AWSの各リソース（ECS, SQS, Secrets Manager等）に対し、必要なアクション（SendMessageのみ等）だけを許可するインラインポリシーをTerraformで定義し、万が一のコンテナ侵害時のリスクを最小化しています。
4. 可観測性 (Observability)
- トレーサビリティ: 分散システム（APIとWorker）において、CloudWatch Logsを活用した一元的なログ管理を実現。エラー発生時に「どのリクエストが、どのWorkerで、なぜ失敗したか」を迅速に追跡できる環境を整えました。
5. IaC (Infrastructure as Code) による再現性
- Terraformによる一元管理: VPC、セキュリティグループからSQS、ECSに至るまで全てのインフラをコード化。手動操作を排除することで、環境構築のヒューマンエラーを防ぎ、本番環境と開発環境の差異を無くしています。
## 5.主な機能
本システムは、標準的なタスク管理機能に加え、大規模利用を想定した通知・最適化機能を備えています。
1. タスク管理機能 (CRUD)
- タスクの作成・一覧表示・更新・削除: RESTful APIに基づいた直感的な操作。各操作において、ログインユーザー本人のデータのみを対象とする厳密な認可処理が行われます。
- ステータス管理: タスクの進行状況（未完了・完了）に応じたリアルタイムな状態管理。
2. リアルタイム通知機能 (WebSocket)
- 即時更新: タスクのステータス変更や期限が近づいた際、ブラウザをリロードすることなく、WebSocketを通じて即座にユーザーへ通知を届けます。
- 高効率な配信ハブ: Goルーチンを用いたハブモデルにより、多数の同時接続を低リソースで維持し、通知の遅延を最小限に抑えています。
3. 非同期バックエンド処理 (Worker)
- タスク期限の自動監視: APIサーバーとは別プロセスのWorkerが、バックグラウンドでタスクの期限を常にチェック。
- SQSによる不揮発な通知配信: 通知処理をメッセージキュー（SQS）に逃がすことで、API側の負荷を下げつつ、通知の「送り漏れ」を防ぐ信頼性の高い配信フローを構築しています。
4. セキュア認証
- JWTによるログイン管理: セキュアなハッシュ化パスワードを用いたサインインと、JWT（JSON Web Token）によるステートレスな認証。
## 6.API設計の考え方
本システムのAPIは、RESTful APIの原則をベースに、実務での運用・デバッグのしやすさを最優先して設計しました。
1. RESTful原則に準拠したエンドポイント
リソース（Task, User）を中心とした直感的な構造を採用しています。
- GET /tasks: ユーザー自身のタスク一覧取得
- POST /tasks: 新規タスク作成
- PUT /tasks/:id: 特定タスクの更新
- DELETE /tasks/:id: 特定タスクの削除 HTTPメソッドとパスを適切に組み合わせ、エンドポイントを一目見ただけで操作内容が理解できるよう設計しました。
2. 厳格な認可（Authorization）ガード
単に「ログインしているか」だけでなく、**「そのリソースを操作する権限があるか」**を全てのAPIで検証しています。
URLパラメータで渡されたIDが存在しても、その user_id が認証中のユーザーと一致しない場合は、一律で 403 Forbidden を返却。
実務で最も重大な事故に繋がる「他人のデータへの不正アクセス」を、ビジネスロジックの最前線で遮断するガードを徹底しています。
3. 一貫性のあるレスポンス形式とステータスコード
クライアント側でのエラーハンドリングを容易にするため、以下のルールを適用しています。
ステータスコードの使い分け:
- 201 Created: 作成成功を明示
- 400 Bad Request: バリデーションエラー（入力不備）
- 401 Unauthorized: 認証エラー
- 429 Too Many Requests: レートリミット適用時
統一エラーレスポンス: エラー時は常に {"error": "メッセージ"} の形式で返却し、フロントエンド側で一元的なトースト通知などが実装しやすいよう配慮しました。
4. バリデーションの徹底
Ginフレームワークの binding:"required" 等を活用し、不正な形式のデータがビジネスロジック（Service層）に到達する前に、Handler層で即座にエラー（400）として遮断する「ガード」を実装しています。
5. 依存性注入（DI）による疎結合
APIハンドラーが特定のデータベース実装に直接依存しないよう設計。将来的なDBの変更や、モックを用いた高速なユニットテストが可能な構造を維持しています。
## 7.エラーハンドリング方針
APIと非同期Workerの双方において、システムの信頼性を維持し、デバッグを容易にするための統一した方針を採用しています。
1. 下位レイヤーからのエラー伝播（Error Wrapping）
- 文脈の付与: Repository層やService層で発生したエラーは、Goの %w 構文を用いてラップし、上位層へ返却します。
- メリット: 最終的なログを見た際に、「どの操作（例：GetTask）の、どの段階（例：DB Query）」で失敗したかというトレース情報を保持したまま、エラーの原因を特定できます。
2. 責務の分離：Handler層への集約
- 変換の統一: HTTPステータスコードへの変換は、最上位の Handler層のみに責務を持たせています。
- 理由: Service層以下に 404 や 500 といったHTTPの概念を持ち込まないことで、ビジネスロジックの純粋性と再利用性を高めています。
- 判定ロジック: Service層からは独自のカスタムエラー（例：ErrNotFound）を返し、Handler層でそれを判定して適切なHTTPレスポンスへ変換します。
3. セキュリティと可観測性の両立
- ユーザー向けレスポンス: セキュリティ保護のため、クライアントには内部的なDBエラー（SQL文など）を隠蔽し、{"error": "リソースが見つかりませんでした"} といった抽象化したメッセージのみを返却します。
- 開発者向けログ: 同時に、CloudWatch Logsには詳細なエラー内容とスタックトレースを出力し、本番環境での迅速な原因究明を可能にしています。
4. 非同期ワーカーの自律的リトライ（SQS）
- 自動リトライ: WorkerがSQSメッセージの処理に失敗した場合、エラーを返してメッセージをキューに留めます。SQSの「可視性タイムアウト」を利用し、一定時間後に自動で再試行（Retry）される仕組みを構築しています。
- 耐障害性 (DLQ): 一定回数リトライしても成功しないメッセージは、システムを停止させるのではなく DLQ（デッドレターキュー） へ隔離します。これにより、異常なデータによる無限ループを防ぎ、後日安全に調査・再投入できる体制を整えています。
## 8.テスト方針
本プロジェクトでは、「継続的な開発を支える信頼性」を確保するため、以下の3段階のテスト戦略を採用しています。

1. ユニットテスト（単体テスト）
- インターフェースを活用したモック化: Goのインターフェース設計を活かし、DBや外部API（SQS等）をモックに差し替えることで、ビジネスロジック（Service層）の独立した検証を可能にしています。
- 網羅性の確保: 正常系だけでなく、バリデーションエラーやDBエラー時の挙動を網羅的にテストし、予期せぬクラッシュを未然に防いでいます。
2. 認可テスト（Authorization Guard）
- 最重要項目としての検証: 「機能が動くか」以上に、「他人のデータにアクセスできないか」を重点的にテストしています。
- 具体例: ユーザーAが、ユーザーBの所有するタスクIDに対して更新・削除リクエストを送った際、適切に 403 Forbidden が返されることを自動テストで保証しています。これにより、実務で致命的となるデータ漏洩リスクをコードレベルで排除しています。
3. インテグレーションテスト（統合テスト）
- 分散フローの検証: 実際の PostgreSQL や Redis コンテナを使用し、システム全体の整合性を確認しています。
- レートリミット: Redisと連携し、短時間の連続リクエストが正しく制限されるかの検証。
- 非同期ライフサイクル: 「APIへのリクエスト → SQSへのメッセージ投入 → Workerによる処理完了」という一連のライフサイクルが正常に動作するかを検証。
- WebSocketの疎通確認: 配信ハブを通じて、正しいクライアントにのみ通知が届くかの検証。
4. CIによる継続的テスト（GitHub Actions）
- デプロイガード: GitHub Actions 上で全てのテストがパスしない限り、AWS（ECS）へのデプロイが行われないようパイプラインを構築しています。これにより、常に正常動作するコードのみが本番環境へ反映される体制を整えました。
## 9.今後の改善予定
本プロジェクトのフェーズ1（基盤構築と非同期通知の実装）を完了し、今後は運用性向上と機能拡張に向けて以下のアップデートを計画しています。
1. セキュリティ・認証基盤の強化
- https接続を可能にする（対応済み）
- PASETOへの移行: 現在のJWTから、よりセキュアな設計（実装ミスが起きにくい構造）であるPASETO（Platform-Agnostic Security Tokens）への切り替えを検討しています。
- 認証機能の拡充: セキュアなログアウト機能の実装、およびリフレッシュトークン導入によるセッション管理の最適化。
2. Observability（可観測性）の最適化
- 構造化ログの導入: CloudWatchでのログ分析をより高度化するため、全てのログをJSON形式の構造化ログ（slog等）に統一し、エラー追跡のスピードを向上させます。（対応済み）
- パフォーマンス計測の定常化: pprof を用いたプロファイリングを定期的に実施し、WebSocket配信ハブのメモリ使用効率をさらに改善します。
3. 機能追加（ビジネスロジックの拡充）
- グループ共有機能: 個人タスクだけでなく、チーム（グループ）単位でのタスク共有・通知機能を実装し、より複雑な認可ロジック（ロールベースアクセス制御：RBAC）へ対応します。
- AIによるタスク分析: OpenAI API等と連携し、蓄積されたタスクデータから優先順位を自動提案する「AIアシスタント機能」の導入を計画しています。
4. テスト・品質管理の深化
- カバレッジの向上: 現在の主要ロジックに加え、エッジケース（ネットワーク遅延時の再試行挙動など）に対するテストコードを強化し、コードカバレッジを高めます。
## 10.自己評価、アピールポイント
1. プロジェクト完遂への意識
本プロジェクトは、1ヶ月での完遂を目標に詳細なWBS（スケジュール表）を作成し、進捗を管理しました。 要件の高度化（WebSocketやSQSの信頼性設計など）により、最終的な開発期間は2ヶ月弱となりましたが、「何が完了し、何が課題か」を常に可視化することで、最後まで妥協せずにインテグレーションテストやCI/CD環境の構築までやり遂げることができました。この経験から、不確実な要素を含む開発におけるリスケジュールと、優先順位判断の重要性を学びました。
2. 品質向上のためのこだわり
「動くこと」の先にある「壊れにくさ・守りの固さ」に注力しました。
- テストの徹底: 開発環境（Docker/go test）、デプロイフロー、本番環境の各フェーズで動作確認を徹底。特に、実務上の重大事故に繋がる「他人のデータ操作」を防ぐための認可テストを最重要項目として自動化しました。
- 実務レベルの運用設計: 踏み台サーバーを排除したSSM接続や、Secrets Managerによる秘匿情報管理など、現場に出ても即戦力として通用するセキュアなインフラ構成を追求しました。
3. 技術的アピールポイント
Goの特性を活かした並行処理システム: GoroutineとChannel、そしてRedisを組み合わせ、効率的かつスケーラブルなリアルタイム通知基盤を自力で設計・実装しました。
- AWSを用いたスケーラブルな構成: ECS Fargate、ALB、RDS、SQSを組み合わせ、トラフィックの増大に柔軟に対応できるモダンなアーキテクチャを採用しています。
- CI/CDによる再現性の高さ: TerraformとGitHub Actionsにより、コマンド一つで環境を100%再現・破棄できる体制を整え、属人性を排除した開発プロセスを実現しました。
## 11.開発者について
1. プロフィール
Delphiを用いた業務システムの開発に3年間従事し、オンプレミス環境でのシステム構築に携わって来ました。左記を継続しつつも現在は、クラウドネイティブな開発意欲により、Go言語とAWSを中心としたスキルアップに注力しています。
2. Go言語への取り組み
2021年より独学を開始しました。「静的型付けによる厳格さ」「コンパイルの速さ」「標準フォーマット（gofmt）の美しさ」に惹かれ、実務外でも以下のツールを自作・運用しています。
- 自作API: Instagramからのデータ取得・加工API
- 画像処理ツール: 画像のリサイズ、圧縮、露光調整アプリケーション
- 業務効率化ツール: 銀行口座CSVの統合・整形スクリプト
3. アルゴリズム・学習への意欲
- LeetCode: 2021年から継続しており、現在までにGo言語で149問を解破。計算量を意識した効率的なコードを書く思考プロセスを磨いています。
- 探求心: Minecraft内でGoプログラムを動かすためにAWS Lightsailを構築したり、趣味の数独を解くアルゴリズムの実装に挑戦したりと、「仕組みを理解し、自動化する」ことを楽しむ気質です。
4. 使用経験のある技術
- 言語: Go, Delphi, PHP, JavaScript, TypeScript
- フロントエンド: React, Next.js, Svelte, WordPress
- インフラ: AWS (ECS, RDS, SQS, ElastiCache, Lambda, S3, etc.), Docker, Terraform
5. 今後の志向
既存のオンプレミス開発の経験を活かしつつ、GoによるクラウドベースのAPI開発や、マイクロサービスアーキテクチャでの開発に深く関わっていきたいと考えています。今後は本ポートフォリオのブラッシュアップ（PASETO導入やグループ機能、AI連携）を通じて、さらに「セキュアでスケーラブルな開発」を追求していきます。
